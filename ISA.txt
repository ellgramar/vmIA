16 bit computer with indirect jumps/branches and load/store
    but 31 bit addressable memory space (4 gig total memory limit for Macbook)

r0-r15 are GPRs
r16   PC    Program Counter
r17   SP    Stack Pointer
r18   FP    Frame Pointer
r19   LR    Link Register
r20   AR    Accumulator Register (used in conjunction with TR, increments when activated)
r21   TR    Target Register (set this to counter target)
r22   SR    Status Register
               znct ispp pppp pppp
               z  zero
               n  negetive
               c  carry/overflow
               t  signed carry/overflow
               i  interrupt flag
               s  screen flag, raised when input is detected. sort of an interrupt
               p  position flags to indicate position when s flag is raised

First nibble opcodes
x0    Escape to n2 opcodes
x1    add
x2    sub
x3    mul
x4    div
x5    rem
x6    and 
x7    nnd 
x8    orr 
x9    nor 
xa    xor 
xb    xnr 
xc    ldi   Load immediate (-2048->2047 | 0->4095)
xd    lod   load indirect / input if r3 > 0x7fff
xe    str   stor indirect / output (char)
xf    jro   jump relative plus(/minus: -2048->2047) offset

lod and str load to/from the register specified in nibble 2 from/to the 
address specified in nibble 3 concatenated with nibble 4 in that order

The screen object is 25 rows and 80 cols giving 2000 positions
these are indexed from 0 to 1999 with positions 2000-2047 being alternate i/o.
If the first register (specified by n2) is greater than or equal to 0x8000,
then instead of store to memory, the value in reg[n2] is masked with 
0x7fff to remove the first bit, then that ascii equivalent character
is sent to the screen at the position specified in the lower two nibbles
of reg[n3] concatinated with reg[n4]. For lod, the value stored at the location 
specified by the lower two nibbles 


E.G. let R0 = 0x0041 (= A = 65 dec), R1 = 0x8000 and R2 = 0x0000; then:
the letter a is loaded into the top left corner or position 0.
instr:  lod r0, r3, r1;
machine code = 0xe 0x0 0x1 0x2 = 1110 0000 0001 0010



Second Nibble opcodes
x00   Escape to n3 opcodes
x01   mov   move n4 to n3
x02   swp   swap n4 and n3
x03   lhi   load high immediate: first nibble of reg[n3] set to n4
x04   not   invert n4 and store in n3
x05   cmp   compare n3, n4: reg[n3] - reg[n4]
x06   cpi   compare immediates in n3 and n4 
x07   beq   branch if equal
x08   bne   branch if not equal
x09   bge   branch if greater than or equal to
x0a   bgt   branch if greater than 
x0b   ble   branch if less than or equal
x0c   blt   branch if less than
x0d   jmp   indirect jump
x0e   sco   screen output
x0f   sci   screen input

Jumps and Branches store the address in the last two nibbles 
which are concatenated together

The screen object is 25 rows and 80 columns giving 2000 locations.
For store (str), the character to be written to is located in reg[n3]
while the location is specified by the lower 12 bits in reg[n4]. For 
load (lod), the location stored in the lower 12 bits of reg[n4] is 
stored in reg[n3]


x000  Escape to n4 commands
x001  inc   increment register
x002  dec   decrement register
x003  psh   mem[SP] = reg[n4], SP--
x004  pop   SP++, reg[n4] = mem[SP]
x005  trs   TR set to reg[n4]
x006  sle   left shift (mul 2)
x007  ssl   (signed shift left)
x008  sri   shift right (fill with zeros, int div 2)
x009  ssr   signed shift right
x00a  rol   rotate left
x00b  srl   signed rotate left
x00c  ror   rotate right
x00d  srr   signed rotate right 
x00e   
x00f  

x0000    ret   return from function (LR and FP)
x0001    nop   PC++
x0002    psha  push all registers to stack and decrement accordingly
x0003    popa  opposit of psha
x0004    ara   Accumulator Register Activate (start counting on every PC++)
x0005    clf   clear all flags
x0006    clz   clear z flag
x0007    cln   clear n flag
x0008    clc   clear c flag
x0009    clt   clear t flag
x000a    cls   clear s flag
x000b
x000c
x000d
x000e
x000f    shutdown
